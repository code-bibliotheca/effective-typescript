# 코드 생성과 타입이 관계없음을 이해하기

### 타입스크립트의 컴파일러 역할

- 최신 TS/JS를 브라우저에서 동작할 수 있도록 구버전의 JS로 트랜스파일링
- 코드의 타입 오류를 체크

> transpile(트랜스파일) : translate(번역) + compile이 합쳐진 신조어 <br>
> 고수준 언어(high-level language)인 TS를 또 하위 수준 언어인 JS로 변환하기 때문에 컴파일과는 구분해서 부름

### 타입스크립트의 역할

- TS가 JS로 변환될 때 코드 내의 타입에는 영향을 주지 않음
- JS의 실행 시점에도 타입은 영향을 미치지 않음
  <br/>

### 1. 타입 오류가 있는 코드도 컴파일이 가능

- 두 가지 역할(트랜스파일, 타입 체크)은 독립적으로 동작하기 때문에, TS는 코드 내 타입오류가 있어도 컴파일이 가능
- 빌드 시 타입에러를 표시해주지만 빌드가 멈추는 것은 아님
- 작성한 TS가 유효한 문법의 JS라면, 컴파일을 수행

  > `tsconfig.json`에 `noEmitOnError` 을 설명하면 오류가 있을 때 빌드 안함

### 2. 런타임에는 타입 체크가 불가능하다

- TS를 컴파일하면 JS로 변환되기 때문에, 컴파일 시의 TS의 타입, 타입구문, 인터페이스는 모두 제거
- 타입정보를 유지하기 위해서 속성체크, 태그기법, Class 를 사용하는 방법이 존재

### 3. 타입 연산은 런타임에 영향을 주지 않는다

### 4. 런타임 타입은 선언된 타입과 다를 수 있다

- TS에서는 런타임 타입과 선언된 타입이 맞지 않을 수 있기 때문에 선언된 타입이 언제든지 달라질 수 있다는 것을 주의하며 스크립트를 작성

### 5. 타입스크립트 타입으로는 함수를 오버로드할 수 없다

- TS는 타입과 런타임 동작이 무관하기 때문에, 함수 오버로딩을 할 수 없음
- TS에서 함수 오버로딩 기능을 지원하기는 함
- 다만, 타입수준에서만 동작하며, 한 함수에 대해 여러 선언문을 작성할 수 있을 뿐이며, 구현체(implementation)은 오직 하나 뿐

### 6. 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다

- 타입과 타입 연산자는 JS로 트랜스파일 시점에 제거되기 때문에 성능에 아무런 영향을 주지 않음(런타임 오버헤드가 없다)
- TS파일을 JS로 컴파일하는 시간이 추가되었기 때문에 ‘빌드타임’ 오버헤드가 존재

<hr>

## 요약

1. 코드 생성과 타입 시스템은 독립적이며 무관하다. 타입스크립트의 타입은 런타임 동작이나 성능에 영향을 주지 않는다.
2. 타입 오류가 존재해도 코드 생성(컴파일)은 가능하다.
3. 런타임 타입과 선언된 타입이 다를 수 있기 때문에, 타입 정보를 유지하는데 방법을 고려해야 함
